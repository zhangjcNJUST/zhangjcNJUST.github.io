<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文阅读(5)--LeGO-LOAM</title>
    <url>/2020/02/16/legoloam/</url>
    <content><![CDATA[<p>论文：<a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM/blob/master/Shan_Englot_IROS_2018_Preprint.pdf" target="_blank" rel="noopener">LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain</a></p>
<p>代码：<a href="https://github.com/RobustFieldAutonomyLab/LeGO-LOAM" target="_blank" rel="noopener">LeGO-LOAM</a></p>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>本文提出了一种轻量级和对地面优化的激光雷达测距与建图方法LeGO-LOAM，用于对地面车辆进行实时的六自由度的位姿估计。LeGO-LOAM是轻量级的，因为它可以在低功耗嵌入式系统上实现实时的位姿估计。LeGO-LOAM也是对地面进行过优化的，因为它在分割和优化步骤中考虑了地面平面存在的影响。本文首先使用点云分割来滤除点云里面的噪声，并且使用特征提取分别得到平面和边缘特征。然后基于平面和边缘特征使用一个两阶段的L-M优化方法来处理连续扫描帧之间的六自由度变换的不同分量。基于地面车辆从多变地形环境采集到的数据，本文将LeGO-LOAM方法与最先进的方法LOAM进行了比较，发现在更少计算开销的情况下，能够取得和LOAM相近的甚至更高的准确度。本文还将LeGO-LOAM集成到一个SLAM框架下来消除漂移引起的位姿估计误差，并在KITTI数据集上进行了测试。</p>
<h1 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h1><h2 id="2-1-System-Overview"><a href="#2-1-System-Overview" class="headerlink" title="2.1 System Overview"></a>2.1 System Overview</h2><p><img src="/2020/02/16/legoloam/image-20200216150502812.png" alt="image-20200216150502812"></p>
<p>框架的总体情况如图所示。系统接收来自3-D激光雷达的输入，输出6自由度的位姿估计。</p>
<p>整个系统被分为五个模块。第一部分，采用单帧的点云将它投影到一个深度图像上用于分割。然后将分段的点云数据发送到特征提取模块，之后，激光里程计使用之前模块提取的特征来寻找连续扫描之间的相关变换。这些特征在激光建图中做进一步处理，将它们配准到一个全局的点云地图上。最后，变换积分单元融合了激光里程计和激光建图的位姿估计并输出最终位姿估计。</p>
<h2 id="2-2-Segmentation"><a href="#2-2-Segmentation" class="headerlink" title="2.2 Segmentation"></a>2.2 Segmentation</h2><p>假设$P_t = \{ p_1,p_2,…,p_n \}$ 是$t$时刻获得的点云，$p_i$是$P_t$中的一个点。首先将$P_t$投影到深度图像上，因为VLP-16的水平和垂直角分辨率为0.2和2，所以深度图像的分辨率为1800*16。$P_t$中的每个有效点$p_i$现在可以用深度图像中的像素唯一表示，$p_i$相对应的深度值$r_i$表示点$p_i$到传感器的欧式距离。</p>
<p>由于倾斜的地形在许多环境中很常见，本文认为地面是不平坦的。在分割之前先对地面点进行提取，采用对深度图像逐列评估的方法。在这个步骤之后，可能是地面的点被标记为地面点并且不用于之后的分割中。</p>
<p>之后，使用一种基于图像的分割方法利用深度图像将点分为不同的聚类，相同聚类的点分配唯一的一个标签，注意地面点为一个特殊的聚类。对点云进行分割能够提高处理效率和特征提取的准确性。假设机器人在嘈杂的环境中进行操作，小的物体，如树叶等将形成不重要的不可靠的特征，因为在连续两帧扫描中不太可能看到相同的一片叶子。为了使用分段点云来实现快速可靠的的特征提取，本文忽略了少于30个点的聚类。在点云分割前后的可视化结果如图所示，原始的点云数据包括从周围植被获得的许多点，这些点可能产生不可靠的特征。</p>
<p><img src="/2020/02/16/legoloam/image-20200216151636332.png" alt="image-20200216151636332"></p>
<p>在这步骤之后，只有表示大物体如树干和地面的那些点将被保留(图2(b))来作进一步的处理，同时，在深度图像中也只保存这些点。</p>
<p>获得了每个点的三个属性:(1)它被视为地面点或分割点的标签，(2)它在深度图像中的行列索引，（3）它的深度值，这些属性会在接下来的模块中用到。</p>
<h2 id="2-3-Feature-Extraction"><a href="#2-3-Feature-Extraction" class="headerlink" title="2.3 Feature Extraction"></a>2.3 Feature Extraction</h2><p>特征提取的方法与LOAM相似，但是本文是从地面点和分割点中提取特征而不是从原始点云数据中提取。</p>
<p>设$S$是深度图像中点$p_i$同一行的连续点集， $p_i$的两侧各有$S$中一半的点。在本文中，设$|S|$为10，使用在分割时计算的深度值，可以估计$S$中每个点$p_i$的粗糙度：</p>
<script type="math/tex; mode=display">
c = {1\over |S|\cdot \|r_i\|}\|\sum_{j\in S,j\neq i}(r_j-r_i)\|</script><p>为了从各个方向均匀地提取特征，将深度图像水平划分为几个相等大小的子图像，然后基于粗糙值$c$对子图像中每一行的点进行排序。和LOAM相似，使用一个阈值$c_{th}$来区分不同类型的特征。称粗糙值$c$大于$c_{th}$的点为边缘特征点，小于$c_{th}$的点为平面特征点。</p>
<p>在每个子图中每行选取不属于地面的$c$值最大的$n_{\mathbb{F}_e}$个边缘特征点，同样地选取每行$c$最小的$n_{\mathbb{F}_p}$个点(可以是地面点)作平面特征点。设$\mathbb{F}_e$和$\mathbb{F}_p$是这些边缘点和平面点的集合，这些特征点如图2(d)中可视化所示。</p>
<p>再从子图每行选取不属于地面的$c$值最大的$n_{F_e}$个边缘点，和必须属于地面的$c$值最小的$n_{F_p}$个边缘点，构成集合$F_e$和$F_p$，如图2(c)所示。$F_e \subset \mathbb{F}_e$,$F_p \subset \mathbb{F}_p$。</p>
<p>本文中，将360°的深度图像分为6个子图，每个子图分辨率为300*16，$n_{F_e},n_{F_p},n_{\mathbb{F}_e},n_{\mathbb{F}_p}$分别选取2，4，40和80。</p>
<h2 id="2-4-Lidar-Odometry"><a href="#2-4-Lidar-Odometry" class="headerlink" title="2.4 Lidar Odometry"></a>2.4 Lidar Odometry</h2><p>激光里程计模块用来估计连续两帧之间的传感器运动。通过进行点对边或者点对面的帧间匹配来寻找两帧之间的变换，换句话说，需要在$F_e^t$和$F_p^t$中找到和前一帧中$\mathbb{F}_e^{t-1}$和$\mathbb{F}_p^{t-1}$相对应的特征点。<br>注意到可以进行一些更改来提高特征匹配的准确性和效率:</p>
<ul>
<li><p>标签匹配:既然$F_e^t$和$F_p^t$中的每个特征在分割后用它的标签来进行编码，只要在$\mathbb{F}_e^{t-1}$和$\mathbb{F}_p^{t-1}$中的相同标签寻找对应关系就行。</p>
<p>对于$F_p^t$中的平面特征，只有在$\mathbb{F}_p^{t-1}中$的被标为地面的点才被用来寻找平面的对应关系。对于$F_e^t$中的边缘特征，它对应的边缘线在$\mathbb{F}_e^{t-1}$中的分割类中寻找。使用这种方法来寻找对应关系可以帮助提高匹配精度，换句话说，两帧之间相同物体的匹配关系更容易被找到。这个过程也缩小了可能的候选对应关系。</p>
</li>
<li><p>两步的L-M优化:通过一系列表示边缘点和平面点之间距离的非线性表达式来表示当前帧和之前帧之间对应关系，并编译成单个的综合距离向量。可以应用L-M方法来找到连续帧之间的最小距离变换。<br>在这里介绍一下两步的L-M优化方法。最佳的转换$T$通过两步来找到：</p>
<ul>
<li><p>$[t_z,\theta_{roll},\theta_{pitch}]$通过$F_p^t$和$\mathbb{F}_p^{t-1}$之间的平面特征点匹配来估计得到</p>
</li>
<li><p>剩下的$[t_x,t_y,\theta_{yaw}]$通过$F_e^t$和$\mathbb{F}_e^{t-1}$之间的边缘特征点匹配来估计得到，并用$[t_z,\theta_{roll},\theta_{pitch}]$作为约束。</p>
</li>
</ul>
<p>应该指出，$[t_x,t_y,\theta_{yaw}]$也可以通过第一步获得，但是它们不太准确，不用于第二步。最终，融合$[t_z,\theta_{roll},\theta_{pitch}]$和$[t_x,t_y,\theta_{yaw}]$获得6维的变换。</p>
<p>通过使用该方法，观察到可以在计算时间减少约35%的情况下实现相似的精度。</p>
</li>
</ul>
<h2 id="2-5-Lidar-Mapping"><a href="#2-5-Lidar-Mapping" class="headerlink" title="2.5 Lidar Mapping"></a>2.5 Lidar Mapping</h2><p>该模块通过将$\{\mathbb{F}_e^t,\mathbb{F}_p^t\}$和一个环境点云地图$\overline Q^{t-1}$进行特征匹配来进一步精细化位姿变换，但是它以一个较低的频率运行。这里将再一次运用L-M方法来获得最终变换。</p>
<p>可以参考LOAM中的表述来获取匹配和优化的细节过程。</p>
<p>LeGO-LOAM中的主要区别是点云地图的存储方法。不同与保存一个单个的点云地图，本文保存集合$\{\mathbb{F}_e^t,\mathbb{F}_p^t\}$中的每个独立特征。假设$M^{t-1}=\{ \{ \mathbb{F}_e^1,\mathbb{F}_p^1 \},…,\{ \mathbb{F}_e^{t-1},\mathbb{F}_p^{t-1} \}\}$为保存所有之前特征的集合。集合$M^{t-1}$中的每个特征也和数据帧被扫描时传感器的位姿相关，因此，可以通过两种方式从$M^{t-1}$中获得地图$\overline Q^{t-1}$。</p>
<ul>
<li>第一种方法，通过选择传感器视场中的特征集合获得。简单起见，可以选择传感器位姿在当前传感器位置100米内的特征集，然后将选择的特征集转换并融合到单个环境地图$\overline Q^{t-1}$，这种地图选择技术和LOAM中的方法类似。</li>
<li>还可以将位姿图SLAM集成到LeGO-LOAM中。每个特征集中的传感器位姿可以作为位姿图中的一个节点。特征集合$\{\mathbb{F}_e^t,\mathbb{F}_p^t\}$可以被看做这个节点的传感器测量。因为激光建图模块的位姿估计漂移非常小，可以假设短时间内没有漂移。于是，$\overline Q^{t-1}$可以通过选择之前一段时间内的特征集组成，如$\overline Q^{t-1}=\{ \{ \mathbb{F}_e^{t-k},\mathbb{F}_p^{t-k} \},…,\{ \mathbb{F}_e^{t-1},\mathbb{F}_p^{t-1} \} \}$，$k$决定了$\overline Q^{t-1}$的大小。之后通过L-M优化后的变换在新节点和$\overline Q^{t-1}$中选择的节点之间添加空间约束。可以通过回环检测来进一步消除这个模块中的漂移，在这种情况下，如果用ICP在当前特征集和之前特征集上找到匹配，新的约束就会建立。只有(D)中的实验使用了这种创建环境地图的方法。</li>
</ul>
<h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h1><p>在带有Cortex-A57的Jetson TX2和带有i7-4710MQ的笔记本电脑两个设备上通过一系列实验来定性和定量比较LOAM和LeGO-LOAM两种算法。这两种算法都用C++实现并在Ubuntu系统上的ROS运行。</p>
<h2 id="3-1-小规模UGV测试"><a href="#3-1-小规模UGV测试" class="headerlink" title="3.1 小规模UGV测试"></a>3.1 小规模UGV测试</h2><p><img src="/2020/02/16/legoloam/image-20200216170919293.png" alt="image-20200216170919293"></p>
<p>如图4d所示，LeGO-LOAM中特征的数目在进行点云分割后大大减少。从树叶返回的大部分点被舍弃了因为它们在多幅扫描中没有稳定的特征。另一方面，从草地返回的点噪声非常大，因此在评估后将得到较大的粗糙度值，使用原始LOAM将不可避免的从这些点中提取边缘特征。如图4c所示，从地面提取的边缘特征通常是不可靠的。尽管在LOAM中可以改变提取边缘和平面特征的粗糙度阈值来减少特征数量并且滤除草和叶子的不稳定特征，但是在做出这些变化后可能得到更差的结果。比如说，可以增大$c_{th}$来从环境中提取更稳定的边缘特征，但是到了相对干净的环境中这种变化将会导致有用的边缘特征数量不足。同样的，减小$c_{th}$时，机器人从干净环境移到嘈杂环境时，也会导致缺乏有用的平面特征。在这里所有的实验中，对LOAM和LeGO-LOAM使用相同的$c_{th}$。</p>
<p><img src="/2020/02/16/legoloam/image-20200216171021390.png" alt="image-20200216171021390"></p>
<p>运行60秒后得到的点云地图如图所示。由于不稳定特征引起的错误的特征关联，LOAM建图在运行期间发散了两次。图5a中用白色箭头标出的三个树干代表现实中的同一棵树。</p>
<h2 id="3-2-大规模UGV测试"><a href="#3-2-大规模UGV测试" class="headerlink" title="3.2 大规模UGV测试"></a>3.2 大规模UGV测试</h2><p><img src="/2020/02/16/legoloam/image-20200216171403069.png" alt="image-20200216171403069"></p>
<ul>
<li>实验一：第一个实验是为了说明在野外环境进行平稳运动时，LOAM和LeGO-LOAM都能实现低漂移的位姿估计。避免了大角度的偏航，也避免了在只能获取少量稳定特征的稀疏区域行驶。在整个数据记录过程中，机器人在平稳道路上进行运动。如图6b所示，机器人的初始位置在一个斜坡上，在以平均速度$1.35m/s$运动$807$秒后，机器人回到相同位置。<br>为了评价两种方法位姿估计的精度，比较初始位姿和最终位姿的平移和选择差异。在所有实验中，初始位姿设为$[0;0;0;0;0;0]$。如表V所示，LOAM和LeGO-LOAM在两种不同硬件配置上实现了相似的低漂移的位姿估计。LeGO-LOAM在Jetson上运行的最终地图如图6b所示。</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216171637709.png" alt="image-20200216171637709"></p>
<ul>
<li><p>实验二：尽管实验二和实验一在相同的环境下进行，它们的运动轨迹略有不同，实验二经过了如图7a所示的一条人行道。这条人行道代表了LOAM可能会经常失败的一种环境。人行道的一端是墙和柱子，从这些结构中可以提取稳定的边缘和平面特征。人行道的另一端是一个有草、树木这些噪声较大物体的开放区域，这些会导致不可靠的特征提取。</p>
<p>结果在这条路上行驶时LOAM的位姿估计发散了，如图7b和d所示。LeGO-LOAM没有这样的问题，原因如下：1) 没有从植被覆盖的地面上提取特征 2) 在分割后滤除了树叶带来的传感器噪声。</p>
<p>两种方法的精度比较如表V所示，在这个实验中，LeGO-LOAM比LOAM的精度高一个数量级。</p>
</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216172002888.png" alt="image-20200216172002888"></p>
<ul>
<li><p>实验三：实验三的数据集来自一个森林徒步旅行小径，在这里面地面无人车辆以$1.3m/s$的平均速度行驶.。机器人在行驶$35$分钟后回到初始位置。环境的海拔变化约为$19$米。地面无人车辆在三种路面上行驶:泥土路，柏油路，和草地。这几种路的代表性图像如图8底部所示。在道路的至少一侧始终存在树木或灌木丛。</p>
<p>首先在这种环境下测试LOAM的准确性。在两台计算机上生成的地图都在不同的位置发散了。在Jetson上最终相对于初始位置的平移和旋转误差为$69.40m$和$27.38°$，在笔记本上为$62.11m$和$8.50°$。在两种硬件上的10次试验轨迹结果如图9a和9b所示。</p>
<p>当LeGO-LOAM在该数据集上运行时，在Jetson上额最终平移和旋转误差为$13.93m$和$7.73°$，笔记本上为$14.87m$和$7.96°$。Jetson上运行LeGO-LOAM生成的最终点云地图如图8所示，覆盖在卫星图像的顶部。图8中放大的局部地图显示该地图与图中开放可见的三棵树匹配的很好。两台计算机上用LeGO-LOAM获取的所有路径都显示出高度的一致性。图9c和d显示了每台计算机上运行的十次试验。</p>
</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216172312188.png" alt="image-20200216172312188"></p>
<p><img src="/2020/02/16/legoloam/image-20200216172338405.png" alt="image-20200216172338405"></p>
<h2 id="3-3-基准测试结果"><a href="#3-3-基准测试结果" class="headerlink" title="3.3 基准测试结果"></a>3.3 基准测试结果</h2><ul>
<li>特征数比较：在表II中展示了两种方法的特征提取比较。每次扫描的特征内容在数据集的10次试验中取平均值。在进行点云分割后，LeGO-LOAM中需要处理的特征数$F_e$,$F_p$,$\mathbb{F}_e$,$\mathbb{F}_p$相应的减少了至少$29\%$，$40\%$，$68\%$，和$72\%$。</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216172708492.png" alt="image-20200216172708492"></p>
<ul>
<li>迭代次数比较：运用提出的两步L-M优化算法的结果如表III所示。首先对LeGO-LOAM使用原始的L-M优化，意味着一起最小化有边缘和平面特征得到的距离函数。之后，对LeGO-LOAM进行两步的L-M优化，录处理一帧L-M方法终止时的平均迭代次数来作比较。当使用两步优化算法时，在实验1和实验2中用两次迭代完成步骤一，虽然步骤二的迭代次数和原始L-M方法接近，但是要处理的特征较少。因此，在使用两步L-M优化后，激光里程计的运行时间减少了$34\%$到$48\%$。</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216172908290.png" alt="image-20200216172908290"></p>
<ul>
<li>运行时间比较：表IV中显示了在两台计算机上LOAM和LeGO-LOAM每个模块的运行时间。使用本文提出的框架，LeGO-LOAM在特征提取和激光里程计模块的运行时间减少了一个数量级。注意LOAM中这两个模块在Jetson上的运行时间超过$100ms$，因此，许多帧会被跳过，LOAM在嵌入式系统上无法实现实时性。当使用LeGO-LOAM时，激光建图的运行时间减少了至少$60\%$。</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216173031718.png" alt="image-20200216173031718"></p>
<ul>
<li>位姿误差比较：通过在所有实验中设置初始位姿为$[0;0;0;0;0;0]$，通过比较最终位姿和初始位姿来计算相对位姿估计误差。对于两台计算机上的两种方法，表V列出了它们的旋转误差(度)和平移误差(米)。通过使用提出的框架，LeGO-LOAM可以用更少的计算时间实现相当的或更好的位姿估计精度。</li>
</ul>
<p><img src="/2020/02/16/legoloam/image-20200216172421384.png" alt="image-20200216172421384"></p>
<h2 id="3-4-KITTI上的回环检测测试"><a href="#3-4-KITTI上的回环检测测试" class="headerlink" title="3.4 KITTI上的回环检测测试"></a>3.4 KITTI上的回环检测测试</h2><p>最终的实验是将LeGO-LOAM应用于KITTI数据集。由于LOAM在KITTI数据集上的测试以实时速度的$10\%$运行，只探讨LeGO-LOAM和它在嵌入式系统上实时应用的潜力，行程的长度对一个完整SLAM方案非常重要。使用序列$00$在Jetson上跑LeGO-LOAM的结果如图10所示。为了在Jetson上实现实时性，对HDL-64E的扫描下采样成与第三节中VLP-16使用的相同的深度图像，换句话说，在处理前，每一帧的$75\%$的点被忽略了。此处使用ICP在位姿图的节点之间添加约束。图使用ISAM2进行优化。最后，使用优化过的图进行传感器位姿校正与建图。</p>
<p><img src="/2020/02/16/legoloam/image-20200216173408564.png" alt="image-20200216173408564"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>本文提出了LeGO-LOAM，这是一种轻量级的和对地面优化过的激光雷达测距与建图方法，用于在复杂环境在对地面无人车辆进行实施位姿估计。<br>虽然LeGO-LOAM是对地面车辆的位姿估计进行专门的优化，但是只要稍作修改，它也可以应用到其他的工具，如无人驾驶飞行器。当将LeGO-LOAM应用于无人驾驶飞行器时，不会假设扫描中存在地面了。一帧点云将在不进行地面提取的情况下进行分割。然后，用原始的L-M方法而不是两步的优化方法来获取两帧之间的转换关系。尽管在这些变化后计算时间将增加，LeGO-LOAM仍然是高效的，因为在分割后户外环境中大量的噪声点被忽略了。</p>
<p>除此之外，LeGO-LOAM在线实现闭环的能力是它成为长时间导航任务中的有效工具。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读(4)--LOAM</title>
    <url>/2020/02/14/loam/</url>
    <content><![CDATA[<p>论文：<a href="https://www.ri.cmu.edu/pub_files/2014/7/Ji_LidarMapping_RSS2014_v8.pdf" target="_blank" rel="noopener">LOAM: Lidar Odometry and Mapping in Real-time</a></p>
<p>代码：</p>
<p><a href="laboshinl/loam_velodyne">laboshinl/loam_velodyne</a></p>
<p><a href="https://github.com/daobilige-su/loam_velodyne" target="_blank" rel="noopener">daobilige-su/loam_velodyne</a></p>
<p><a href="HKUST/A-LOAM">HKUST/A-LOAM</a></p>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>本文提出了一个使用6自由度运动的2轴激光雷达的实时测距与建图方法。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>学习STL</title>
    <url>/2020/02/07/stl/</url>
    <content><![CDATA[<p>参考：</p>
<p>STL基本概念：标准模板库，广义上分为容器、算法、迭代器</p>
<p>STL六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>
<p>容器：各种数据结构，vector、list…</p>
<p>算法：各种常用算法：sort、find、copy…</p>
<p>迭代器：</p>
<p>仿函数：</p>
<p>适配器：</p>
]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>学习docker</title>
    <url>/2020/02/05/docker/</url>
    <content><![CDATA[<p>参考：深入浅出docker</p>
<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p><img src="/2020/02/05/docker/image-20200214161141013.png" alt="image-20200214161141013"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>过滤ls返回内容  —filter</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls --filter dangling=true</span><br></pre></td></tr></table></figure>
<p>dangling：true和false，返回悬虚镜像或者非悬虚镜像</p>
<p>before:加镜像名称或ID，返回在这之前被创建的全部镜像</p>
<p>since:同上，返回这之后被创建的全部镜像</p>
<p>label:根据label名称或值对镜像进行过滤</p>
<p>使用reference</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls --filter=reference="*:latest"</span><br></pre></td></tr></table></figure>
<p>—format 对输出内容格式化</p>
<p>拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image pull ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>镜像仓库  默认Docker Hub</p>
<p>搜索docker hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search</span><br></pre></td></tr></table></figure>
<p>镜像命名和标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image pull &lt;repository&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>查看镜像分层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image inspect ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>删除镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm 0233123(id)</span><br></pre></td></tr></table></figure>
<p>删除全部镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm $(docker image ls -q) -f</span><br></pre></td></tr></table></figure>
<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>容器 vs 虚拟机</p>
<p><img src="/2020/02/05/docker/image-20200214162510509.png" alt="image-20200214162510509"></p>
<p><img src="/2020/02/05/docker/image-20200214162522256.png" alt="image-20200214162522256"></p>
<p>检查docker daemon 状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>若无权限访问，加sudo或加入当前用户到docker组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -aG docker &lt;user&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker status</span><br><span class="line">systemctl is-activate docker</span><br></pre></td></tr></table></figure>
<p>启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -it ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run --name a -it ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
<p>格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run &lt;options&gt; &lt;image&gt;:&lt;tag&gt; &lt;app&gt;</span><br></pre></td></tr></table></figure>
<p><code>ctrl+p+q</code>退出但不终止容器</p>
<p>重连到容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container exec -it 3207eb124 bash</span><br></pre></td></tr></table></figure>
<p>确认容器状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ps</span><br></pre></td></tr></table></figure>
<p>停止删除容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container stop 30232&lt;name or id&gt;</span><br><span class="line">docker container rm 30232</span><br></pre></td></tr></table></figure>
<p>启动已stop的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container start &lt;&gt;</span><br></pre></td></tr></table></figure>
<p>利用重启策略进行容器的自我修复</p>
<p>作为参数传入run 命令或者写入compose文件</p>
<p>always：除非容器被明确停止，一直尝试重启、当daemon重启时，停止的容器也重启</p>
<p>unless-stopped：与always区别，不会在daemon重启时重启(<code>systemlctl restart docker</code>) </p>
<p>on-failed：退出容器且返回值不是0的时候重启容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -d --name always --restart always alpine sleep 1d</span><br></pre></td></tr></table></figure>
<p>查看容器详情</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container inspect</span><br></pre></td></tr></table></figure>
<p>快速清理所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container rm $(docker container ls -aq) -f</span><br></pre></td></tr></table></figure>
<h1 id="应用的容器化"><a href="#应用的容器化" class="headerlink" title="应用的容器化"></a>应用的容器化</h1><p>基本过程</p>
<p><img src="/2020/02/05/docker/image-20200214164637940.png" alt="image-20200214164637940"></p>
<ul>
<li>编写应用代码</li>
<li>创建Dockerfile文件</li>
<li>对该Dockerfile执行<code>docker image build</code></li>
<li>等待Docker将应用程序构建到Docker镜像中</li>
</ul>
<p>Dockerfile:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine <span class="comment">#指定基础镜像</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer = <span class="string">"xxx@sss.com"</span> <span class="comment">#指定当前镜像维护者</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update nodejs nodejs-npm <span class="comment">#按照nodejs nodejs-npm到当前镜像中</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /src </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span> <span class="comment">#设置相应端口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"./app.js"</span>] <span class="comment">#指定当前对象的入口程序</span></span></span><br></pre></td></tr></table></figure>
<p>注释以#开头</p>
<p>其他dockerfile指令：LABEL ENV ONBUILD HEALTHCHECK CMD等</p>
<p>指令格式 指令不区分大小写，一般大写</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">INSTRUCTION argument</span><br></pre></td></tr></table></figure>
<p><code>FROM</code> <code>RUN</code> <code>COPY</code>会创建新的镜像层</p>
<p>如果指令的作用是向镜像中增添新的文件或者程序，这条指令就会新建镜像层；</p>
<p>如果只是告诉docker如何完成构建或者如何运行应用程序，只会增加镜像的元数据、</p>
<p>docker镜像体积应尽量小</p>
<p><code>RUN</code>指令会新增一个镜像层，因此，通过使用<code>&amp;&amp;</code>连接多个命令以及使用<code>\</code>换行，将多个命令包含在一个<code>RUN</code>指令中。</p>
<p>构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image build -t web:latest .</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container run -d --name c -p 80:8080 web:latest</span><br></pre></td></tr></table></figure>
<p>多阶段构建</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:latest AS storefront <span class="comment">#阶段0 拉去node:latest </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/atsea/app/react-app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> react-app .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> maven:latest AS appserver <span class="comment">#阶段1</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/atsea</span></span><br><span class="line"><span class="keyword">copy</span><span class="bash"> pom.xml .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml ???</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn ????</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jdk-apline AS production <span class="comment">#阶段2</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> adduser -Dh /home/grodon grodon</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /static</span></span><br><span class="line"><span class="comment">#从之前阶段构建的镜像中仅复制生产环境相关的应用代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=storefront /usr/src/atsea/app/react-app/build .</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app/Atsea-0.0.1-SNAPSHOT.jar"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"--spring.profiles.active=postgres"</span>]</span></span><br></pre></td></tr></table></figure>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>在Docker节点上，以单引擎模式进行多容器应用的部署和管理</p>
<p>待续……</p>
<h1 id="Docker-Stack"><a href="#Docker-Stack" class="headerlink" title="Docker Stack"></a>Docker Stack</h1><p>以Swarm模式对Docker节点上的多容器应用进行部署和管理</p>
<p>待续……</p>
]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>学习bazel</title>
    <url>/2020/02/03/bazel/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://docs.bazel.build/versions/master/tutorial/cpp.html" target="_blank" rel="noopener">Introduction to Bazel: Building a C++ Project</a> </p>
<p><a href="https://docs.bazel.build/versions/master/external.html" target="_blank" rel="noopener">Working with external dependencies</a></p>
<h1 id="1-Cpp-turorial"><a href="#1-Cpp-turorial" class="headerlink" title="1. Cpp-turorial"></a>1. Cpp-turorial</h1><p><img src="/2020/02/03/bazel/image-20200208150619959.png" alt="image-20200208150619959"></p>
<h2 id="1-1-Set-workspace"><a href="#1-1-Set-workspace" class="headerlink" title="1.1 Set workspace"></a>1.1 Set workspace</h2><p> A workspace is a directory that holds your project’s source files and Bazel’s build outputs.</p>
<p> It also contains files that Bazel recognizes as special:</p>
<ul>
<li>WORKSPACE文件，放在项目根目录下</li>
<li>BUILD文件，tell Bazel how to build different parts of the project. WORKSPACE中一个包含BUILD文件的目录是一个package.</li>
</ul>
<h2 id="1-2-BUILD-file"><a href="#1-2-BUILD-file" class="headerlink" title="1.2 BUILD file"></a>1.2 BUILD file</h2><p> A <code>BUILD</code> file contains several different types of instructions for Bazel.</p>
<p>The most important type is the <em>build rule</em>, which tells Bazel how to build the desired outputs, such as executable binaries or libraries. </p>
<p> Each instance of a build rule in the <code>BUILD</code> file is called a <em>target</em> and points to a specific set of source files and dependencies. A target can also point to other targets.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.bazel.build/versions/master/be/c-cpp.html#cc_binary" target="_blank" rel="noopener"><code>cc_binary</code> rule</a></p>
<p>The rule tells Bazel to build a self-contained executable binary from the <code>hello-world.cc</code> source file with no dependencies.</p>
<h2 id="1-3-Build-the-project"><a href="#1-3-Build-the-project" class="headerlink" title="1.3 Build the project"></a>1.3 Build the project</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure>
<p><code>//main:</code>  target label</p>
<p>build outputs in bazel-in directory</p>
<h2 id="1-4-Review-the-dependency-graph"><a href="#1-4-Review-the-dependency-graph" class="headerlink" title="1.4 Review the dependency graph"></a>1.4 Review the dependency graph</h2><p>generate a text representation</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bazel query --notool_deps --noimplicit_deps 'deps(//main:hello-world)' \</span><br><span class="line">  --output graph</span><br></pre></td></tr></table></figure>
<p>paste the text into GraphViz.</p>
<p>install GraphViz and xdot Dot Viewer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install graphviz xdot</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xdot &lt;(bazel query --notool_deps --noimplicit_deps 'deps(//main:hello-world)' \</span><br><span class="line">  --output graph)</span><br></pre></td></tr></table></figure>
<h2 id="1-5-Multiple-build-targets"><a href="#1-5-Multiple-build-targets" class="headerlink" title="1.5 Multiple build targets"></a>1.5 Multiple build targets</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;hello-greet&quot;,</span><br><span class="line">    srcs = [&quot;hello-greet.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-greet.h&quot;],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">    deps = [</span><br><span class="line">        &quot;:hello-greet&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>first builds the <code>hello-greet</code> library (using Bazel’s built-in <a href="https://docs.bazel.build/versions/master/be/c-cpp.html#cc_library" target="_blank" rel="noopener"><code>cc_library</code> rule</a>)</p>
<p>then the <code>hello-world</code> binary</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/03/bazel/image-20200208154634444.png" alt="image-20200208154634444"></p>
<h2 id="1-6-Multiple-packages"><a href="#1-6-Multiple-packages" class="headerlink" title="1.6 Multiple packages"></a>1.6 Multiple packages</h2><p><img src="/2020/02/03/bazel/image-20200208154718695.png" alt="image-20200208154718695"></p>
<p>lib/BUILD file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;hello-time&quot;,</span><br><span class="line">    srcs = [&quot;hello-time.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-time.h&quot;],</span><br><span class="line">    visibility = [&quot;//main:__pkg__&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>make the <code>//lib:hello-time</code> target in <code>lib/BUILD</code> explicitly visible to targets in <code>main/BUILD</code> using the <code>visibility</code> attribute.</p>
<p> This is because by default targets are only visible to other targets in the same <code>BUILD</code> file. (Bazel uses target visibility to prevent issues such as libraries containing implementation details leaking into public APIs.)</p>
<p>main/BUILD file:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;hello-greet&quot;,</span><br><span class="line">    srcs = [&quot;hello-greet.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-greet.h&quot;],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">    deps = [</span><br><span class="line">        &quot;:hello-greet&quot;,</span><br><span class="line">        &quot;//lib:hello-time&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/03/bazel/image-20200208155111217.png" alt="image-20200208155111217"></p>
<h2 id="1-7-Using-labels-to-reference-targets"><a href="#1-7-Using-labels-to-reference-targets" class="headerlink" title="1.7 Using labels to reference targets"></a>1.7 Using labels to reference targets</h2><p>In <code>BUILD</code> files and at the command line, Bazel uses <em>labels</em> to reference targets - for example, <code>//main:hello-world</code> or <code>//lib:hello-time</code>. </p>
<p>Their syntax is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//path/to/package:target-name</span><br></pre></td></tr></table></figure>
<h1 id="2-Working-with-external-dependencies"><a href="#2-Working-with-external-dependencies" class="headerlink" title="2. Working with external dependencies"></a>2. Working with external dependencies</h1><p>depend on targets from other projects.</p>
<h2 id="2-1-Depending-on-other-Bazel-projects"><a href="#2-1-Depending-on-other-Bazel-projects" class="headerlink" title="2.1 Depending on other Bazel projects"></a>2.1 Depending on other Bazel projects</h2><p>use <a href="http://docs.bazel.build/be/workspace.html#local_repository" target="_blank" rel="noopener"><code>local_repository</code></a>, <a href="https://docs.bazel.build/versions/master/repo/git.html#git_repository" target="_blank" rel="noopener"><code>git_repository</code></a> or <a href="https://docs.bazel.build/versions/master/repo/http.html#http_archive" target="_blank" rel="noopener"><code>http_archive</code></a> to symlink it from the local filesystem, reference a git repository or download it (respectively)</p>
<p>example（add to WORKSPACE）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_repository(</span><br><span class="line">    name = &quot;coworkers_project&quot;,</span><br><span class="line">    path = &quot;/path/to/coworkers-project&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Depending-on-non-Bazel-projects"><a href="#2-2-Depending-on-non-Bazel-projects" class="headerlink" title="2.2 Depending on non-Bazel projects"></a>2.2 Depending on non-Bazel projects</h2><p> prefixed with <code>new_</code> , e.g. <a href="http://docs.bazel.build/be/workspace.html#new_local_repository" target="_blank" rel="noopener"><code>new_local_repository</code></a></p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_local_repository(</span><br><span class="line">    name = &quot;coworkers_project&quot;,</span><br><span class="line">    path = &quot;/path/to/coworkers-project&quot;,</span><br><span class="line">    build_file = &quot;coworker.BUILD&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>build_file</code> specifies a BUILD file to overlay on the existing project</p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;some-lib&quot;,</span><br><span class="line">    srcs = glob([&quot;**&quot;]),</span><br><span class="line">    visibility = [&quot;//visibility:public&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> then depend on <code>@coworkers_project//:some-lib</code> from your project’s BUILD files</p>
<h2 id="2-3-Fetching-dependencies"><a href="#2-3-Fetching-dependencies" class="headerlink" title="2.3 Fetching dependencies"></a>2.3 Fetching dependencies</h2><p>By default, external dependencies are fetched as needed during <code>bazel build</code>.</p>
<p>If you would like to prefetch the dependencies needed for a specific set of targets, use <a href="https://docs.bazel.build/versions/master/command-line-reference.html#commands" target="_blank" rel="noopener"><code>bazel fetch</code></a>. </p>
<p>To unconditionally fetch all external dependencies, use <a href="https://docs.bazel.build/versions/master/command-line-reference.html#commands" target="_blank" rel="noopener"><code>bazel sync</code></a>. </p>
<p>As fetched repositories are <a href="https://docs.bazel.build/versions/master/external.html#layout" target="_blank" rel="noopener">stored in the output base</a>, fetching happens per workspace.</p>
<h2 id="2-4-Caching-of-external-dependencies"><a href="#2-4-Caching-of-external-dependencies" class="headerlink" title="2.4 Caching of external dependencies"></a>2.4 Caching of external dependencies</h2><p>By default, Bazel will only re-download external dependencies if their definition changes. </p>
<p>Changes to files referenced in the definition (e.g., patches or <code>BUILD</code> files) are also taken into account by bazel.</p>
<p>To force a re-download, use <code>bazel sync</code></p>
<p>External dependencies are all downloaded to a directory under the subdirectory <code>external</code> in the <a href="https://docs.bazel.build/versions/master/output_directories.html" target="_blank" rel="noopener">output base</a></p>
<p>In case of a <a href="https://docs.bazel.build/versions/master/be/workspace.html#local_repository" target="_blank" rel="noopener">local repository</a>, a symlink is created there instead of creating a new directory.</p>
<p>see the <code>external</code> directory by running:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls $(bazel info output_base)/external</span><br></pre></td></tr></table></figure>
<h2 id="2-5-Offline-build"><a href="#2-5-Offline-build" class="headerlink" title="2.5 Offline build"></a>2.5 Offline build</h2><p><a href="https://docs.bazel.build/versions/master/external.html#fetching-dependencies" target="_blank" rel="noopener">prefetching</a> the needed repositories with <code>bazel fetch</code> or <code>bazel sync</code> can be enough;</p>
<p> moreover, the using the option <code>--nofetch</code>, fetching of further repositories can be disabled during the build.</p>
<p>For true offline builds, where the providing of the needed files is to be done by an entity different from bazel, bazel supports the option <code>--distdir</code>. Whenever a repository rule asks bazel to fetch a file via <a href="https://docs.bazel.build/versions/master/skylark/lib/repository_ctx.html#download" target="_blank" rel="noopener"><code>ctx.download</code></a> or <a href="https://docs.bazel.build/versions/master/skylark/lib/repository_ctx.html#download_and_extract" target="_blank" rel="noopener"><code>ctx.download_and_extract</code></a> and provides a hash sum of the file needed, bazel will first look into the directories specified by that option for a file matching the basename of the first URL provided, and use that local copy if the hash matches.</p>
<p>However, bazel allows the execution of arbitrary commands in repository rules, without knowing if they call out to the network. Therefore, bazel has no option to enforce builds being fully offline. So testing if a build works correctly offline requires external blocking of the network, as bazel does in its bootstrap test.</p>
<h2 id="2-6-Best-practices"><a href="#2-6-Best-practices" class="headerlink" title="2.6 Best practices"></a>2.6 Best practices</h2><ul>
<li>Prefer <a href="https://docs.bazel.build/versions/master/repo/http.html#http_archive" target="_blank" rel="noopener"><code>http_archive</code></a> to <code>git_repository</code> and <code>new_git_repository</code>.</li>
<li>Do not use <code>bind()</code>. </li>
<li>Avoid using <code>repository_ctx.execute</code> when possible.when using a non-Bazel C++ library that has a build using Make, it is preferable to use <code>repository_ctx.download()</code> and then write a BUILD file that builds it, instead of running <code>ctx.execute([&quot;make&quot;])</code>.</li>
</ul>
]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>bazel</tag>
      </tags>
  </entry>
  <entry>
    <title>点云投影(3)--投影到图像</title>
    <url>/2020/02/03/proj2img/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>激光雷达</category>
      </categories>
      <tags>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读(3)--pointGrid</title>
    <url>/2020/02/03/pointgrid/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>cls.</tag>
        <tag>seg.</tag>
        <tag>det.</tag>
      </tags>
  </entry>
  <entry>
    <title>学习protocol buffers</title>
    <url>/2020/02/02/protobuf/</url>
    <content><![CDATA[<p>参考：<a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Protocol Buffers</a></p>
<h1 id="1-什么是protocol-buffers"><a href="#1-什么是protocol-buffers" class="headerlink" title="1. 什么是protocol buffers"></a>1. 什么是protocol buffers</h1><p> a flexible, efficient, automated mechanism for serializing structured data – think XML</p>
<p>smaller、faster、simpler</p>
<h1 id="2-怎样工作"><a href="#2-怎样工作" class="headerlink" title="2. 怎样工作"></a>2. 怎样工作</h1><p>通过.proto文件定义protocol buffer 消息类型</p>
<p>一个person消息的样例:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">required</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">required</span> <span class="built_in">int32</span> id = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span></span>&#123;</span><br><span class="line">		MOBILE = <span class="number">0</span>;</span><br><span class="line">		HOME = <span class="number">1</span>;</span><br><span class="line">		WORK = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span></span>&#123;</span><br><span class="line">		<span class="keyword">required</span> <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">optional</span> PhoneType type = <span class="number">2</span>[defalt = HOME];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">required</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行编译器后生成一个Person类，可以在代码中使用,如下(c++为例)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write</span></span><br><span class="line">Person person;</span><br><span class="line">person.set_name(<span class="string">"zhangjc"</span>);</span><br><span class="line">person.set_id(<span class="number">1234</span>);</span><br><span class="line">person.set_email(<span class="string">"zhangjc_qq.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">fstream <span class="title">output</span><span class="params">(<span class="string">"myfile"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">person.SerializeToOstream(&amp;output);</span><br><span class="line"></span><br><span class="line"><span class="comment">// read</span></span><br><span class="line"><span class="function">fstream <span class="title">input</span><span class="params">(<span class="string">"myfile"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">Person person;</span><br><span class="line">person.ParseFromIstream(&amp;input);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; person.id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"email:"</span> &lt;&lt; person.email() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="3-如何定义proto-消息"><a href="#3-如何定义proto-消息" class="headerlink" title="3. 如何定义proto 消息"></a>3. 如何定义proto 消息</h1><p><strong>Prefer Proto3</strong> While <code>proto2</code> will continue to be supported, we encourage new code to use <code>proto3</code> instead, which is easier to use and supports more languages.</p>
<h2 id="3-1-proto2"><a href="#3-1-proto2" class="headerlink" title="3.1 proto2"></a>3.1 proto2</h2><p>fields：键-值对，如<code>required string name = 1;</code> </p>
<p>field numbers：消息定义中的每一个field有一个独一无二的号码，一旦使用不修改，范围1-536,870,911($2^{29}-1$ )，其中19000-19999不能使用。</p>
<p>field rules：</p>
<ul>
<li>required：必须有一个</li>
<li>optional：有0各或一个，当没有时，将使用默认值，默认值可以在文件中定义，未定义时，根据不同的类型使用不同的默认值，strings-&gt;empty string,bytes-&gt;empty byte string,bools-&gt;false,numeric -&gt; zero, enums-&gt;first value listed in the enum’s type definition</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>repeated：可以有任意个(包括0)</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span>[packed = <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>
<p>一个.proto文件中可以定义多个消息类型。</p>
<p>.proto文件中的注释：与C/C++中一样</p>
<p>reserved field：防止某些删除了的field number被重新定义，加载旧版本时出问题，example:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">	reserved <span class="number">2</span>,<span class="number">15</span>,<span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">	reserved <span class="string">"foo"</span>, <span class="string">"bar"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.proto文件编译后生成什么：</p>
<ul>
<li>C++: .h和.cc文件，每个消息类型生成一个类</li>
<li>Python：generates a module with a static descriptor of each message type in your <code>.proto</code>, which is then used with a <em>metaclass</em> to create the necessary Python data access class at runtime.</li>
</ul>
<p>可以定义的标量类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">.proto Type</th>
<th style="text-align:left">Notes</th>
<th style="text-align:left">C++ Type</th>
<th style="text-align:left">Java Type</th>
<th style="text-align:left">Python Type[2]</th>
<th style="text-align:center">Go Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left"></td>
<td style="text-align:left">double</td>
<td style="text-align:left">double</td>
<td style="text-align:left">float</td>
<td style="text-align:center">*float64</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left"></td>
<td style="text-align:left">float</td>
<td style="text-align:left">float</td>
<td style="text-align:left">float</td>
<td style="text-align:center">*float32</td>
</tr>
<tr>
<td style="text-align:left">int32</td>
<td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
<td style="text-align:left">int32</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int</td>
<td style="text-align:center">*int32</td>
</tr>
<tr>
<td style="text-align:left">int64</td>
<td style="text-align:left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
<td style="text-align:left">int64</td>
<td style="text-align:left">long</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*int64</td>
</tr>
<tr>
<td style="text-align:left">uint32</td>
<td style="text-align:left">Uses variable-length encoding.</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">int[1]</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*uint32</td>
</tr>
<tr>
<td style="text-align:left">uint64</td>
<td style="text-align:left">Uses variable-length encoding.</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">long[1]</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*uint64</td>
</tr>
<tr>
<td style="text-align:left">sint32</td>
<td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td style="text-align:left">int32</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int</td>
<td style="text-align:center">*int32</td>
</tr>
<tr>
<td style="text-align:left">sint64</td>
<td style="text-align:left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td style="text-align:left">int64</td>
<td style="text-align:left">long</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*int64</td>
</tr>
<tr>
<td style="text-align:left">fixed32</td>
<td style="text-align:left">Always four bytes. More efficient than uint32 if values are often greater than 228.</td>
<td style="text-align:left">uint32</td>
<td style="text-align:left">int[1]</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*uint32</td>
</tr>
<tr>
<td style="text-align:left">fixed64</td>
<td style="text-align:left">Always eight bytes. More efficient than uint64 if values are often greater than 256.</td>
<td style="text-align:left">uint64</td>
<td style="text-align:left">long[1]</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*uint64</td>
</tr>
<tr>
<td style="text-align:left">sfixed32</td>
<td style="text-align:left">Always four bytes.</td>
<td style="text-align:left">int32</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int</td>
<td style="text-align:center">*int32</td>
</tr>
<tr>
<td style="text-align:left">sfixed64</td>
<td style="text-align:left">Always eight bytes.</td>
<td style="text-align:left">int64</td>
<td style="text-align:left">long</td>
<td style="text-align:left">int/long[3]</td>
<td style="text-align:center">*int64</td>
</tr>
<tr>
<td style="text-align:left">bool</td>
<td style="text-align:left"></td>
<td style="text-align:left">bool</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">bool</td>
<td style="text-align:center">*bool</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">A string must always contain UTF-8 encoded or 7-bit ASCII text.</td>
<td style="text-align:left">string</td>
<td style="text-align:left">String</td>
<td style="text-align:left">unicode (Python 2) or str (Python 3)</td>
<td style="text-align:center">*string</td>
</tr>
<tr>
<td style="text-align:left">bytes</td>
<td style="text-align:left">May contain any arbitrary sequence of bytes.</td>
<td style="text-align:left">string</td>
<td style="text-align:left">ByteString</td>
<td style="text-align:left">bytes</td>
<td style="text-align:center">[]byte</td>
</tr>
</tbody>
</table>
</div>
<p>其他消息类型的使用：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从其他文件中导入</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</span><br></pre></td></tr></table></figure>
<p>嵌套定义</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extension</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  extensions <span class="number">100</span> to <span class="number">199</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再Foo的初始定义中加入了一个bar</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">126</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给extension设置值(c++)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.SetExtension(bar, <span class="number">15</span>);</span><br><span class="line"><span class="comment">//HasExtension(), ClearExtension(), GetExtension,MutableExtension(), and AddExtension()</span></span><br></pre></td></tr></table></figure>
<p>Oneof：</p>
<p>Oneof fields are like optional fields except all the fields in a oneof share memory, and at most one field can be set at the same time.</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">     <span class="built_in">string</span> name = <span class="number">4</span>; <span class="comment">// 没有 required optional repeated</span></span><br><span class="line">     SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>maps, packages ……</p>
<p>更新一个消息类型：</p>
<ul>
<li>不要改变已有filed的number</li>
<li>新加的field必须是optional或repeated</li>
<li>除required的field外可以删除，但是它的field number不能再被使用</li>
<li>只要类型和number保持不变，非requried的field可以变为extension和vice versa</li>
<li>int32、uint32、int64、uint64、bool互相兼容</li>
<li>sint32和sint64互相兼容</li>
<li>string 和bytes互相兼容只要bytes是有效的UTF-8</li>
<li>fixed32-&gt;sfixed32</li>
<li>fixed64-&gt;sfixed64</li>
<li>optional-&gt;repeated</li>
<li>可以改变默认值</li>
<li>enum -&gt; int32 uint32 int64 uint64</li>
<li>optional -&gt; oneof</li>
</ul>
<h2 id="3-2-proto3"><a href="#3-2-proto3" class="headerlink" title="3.2 proto3"></a>3.2 proto3</h2><p>example:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>field rules:</p>
<ul>
<li>singular：默认，zero or one</li>
<li>repeated：any number of times</li>
</ul>
<h2 id="3-3-style"><a href="#3-3-style" class="headerlink" title="3.3 style"></a>3.3 style</h2><ul>
<li>每一行最多80个字符</li>
<li>两个空格进行缩进</li>
<li>文件命名：lower_snake_case.proto</li>
<li>文件结构：<ul>
<li>License header (if applicable)</li>
<li>File overview</li>
<li>Syntax</li>
<li>Package</li>
<li>Imports (sorted)</li>
<li>File options</li>
<li>Everything else</li>
</ul>
</li>
<li>package name 小写，与目录结构对应my/package -&gt; my.package</li>
<li>message，CamelCase; field, underscore_separated_names;</li>
<li>repeated field用复数，如 repeated string keys  = 1；</li>
<li>Enums, CamelCase</li>
<li>Services, CamelCase</li>
</ul>
]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>protocol buffers</tag>
      </tags>
  </entry>
  <entry>
    <title>点云投影(2)--投影到圆柱展开面</title>
    <url>/2020/01/31/projection2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>激光雷达</category>
      </categories>
      <tags>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>点云投影(1)--投影到XY平面(鸟瞰图)</title>
    <url>/2020/01/31/projection1/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_33801763/article/details/78923310" target="_blank" rel="noopener">处理点云数据(一)：点云与生成鸟瞰图</a></p>
<h1 id="1-图像坐标系与激光雷达坐标系"><a href="#1-图像坐标系与激光雷达坐标系" class="headerlink" title="1. 图像坐标系与激光雷达坐标系"></a>1. 图像坐标系与激光雷达坐标系</h1><p><img src="/2020/01/31/projection1/1.png" alt="1" style="zoom: 33%;"></p>
<p>图像坐标系：</p>
<ul>
<li>原点左上角</li>
<li>坐标值都为正</li>
<li>坐标值都是整数</li>
</ul>
<p><img src="/2020/01/31/projection1/2.png" alt="2" style="zoom:33%;"></p>
<p>点云坐标系：</p>
<ul>
<li>左方为Y轴正方向、前方为X轴正方向、上方为Z轴正方向</li>
<li>坐标值有正有负</li>
<li>坐标值为实数</li>
</ul>
<h1 id="2-创建鸟瞰图投影"><a href="#2-创建鸟瞰图投影" class="headerlink" title="2. 创建鸟瞰图投影"></a>2. 创建鸟瞰图投影</h1><h2 id="2-1-选择投影区域"><a href="#2-1-选择投影区域" class="headerlink" title="2.1 选择投影区域"></a>2.1 选择投影区域</h2><p>一般情况下，只关注车体附近一定范围内的点云，无需对所有点云进行处理，本文选择车身左右各10m，车后20m，车前40m作为感兴趣区域。</p>
<h2 id="2-2-设置投影分辨率"><a href="#2-2-设置投影分辨率" class="headerlink" title="2.2 设置投影分辨率"></a>2.2 设置投影分辨率</h2><p>设置每个像素所代表的区域范围，本文设置分辨率res为0.05m，则生成投影图的高度为$ 60 / 0.05 = 1200$，宽度为$20 / 0.05 = 400$。</p>
<h2 id="2-3-将每个点映射到像素位置"><a href="#2-3-将每个点映射到像素位置" class="headerlink" title="2.3 将每个点映射到像素位置"></a>2.3 将每个点映射到像素位置</h2><p>映射公式：</p>
<script type="math/tex; mode=display">
col = [-y / res] + \lfloor leftoffset / res \rfloor</script><script type="math/tex; mode=display">
row = [-x / res] + \lceil forwardoffset / res \rceil</script><p>其中，$leftoffset$和$forwardoffset$为车左方和前方的最大距离，均为正值，目的是是将转换后的原点变为左上角，坐标值都为正。</p>
<h2 id="2-4-填充像素值"><a href="#2-4-填充像素值" class="headerlink" title="2.4 填充像素值"></a>2.4 填充像素值</h2><p>将所有点的Z值归一化到0-255后，赋值给每个点对应位置的像素值。</p>
<h1 id="3-可视化结果"><a href="#3-可视化结果" class="headerlink" title="3. 可视化结果"></a>3. 可视化结果</h1><p><img src="/2020/01/31/projection1/3.png" alt="3" style="zoom:200%;"></p>
<h1 id="4-相关代码"><a href="#4-相关代码" class="headerlink" title="4. 相关代码"></a>4. 相关代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_velodyne_points</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">""" load lidar data from .bin file </span></span><br><span class="line"><span class="string">        [https://github.com/hunse/kitti]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    points = np.fromfile(filename, dtype = np.float32).reshape(<span class="number">-1</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># remove intensity</span></span><br><span class="line">    points = points[:,<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    data_file = <span class="string">"./data.bin"</span></span><br><span class="line">    points = load_velodyne_points(data_file)</span><br><span class="line">    <span class="comment">#print(points.shape) #55597*3</span></span><br><span class="line">    <span class="comment">#print(points[:20])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose ROI</span></span><br><span class="line">    <span class="comment"># left 10,right 10,back 20.forward 40</span></span><br><span class="line">    side_range = (<span class="number">-10</span>, <span class="number">10</span>)</span><br><span class="line">    fwd_range = (<span class="number">-20</span>, <span class="number">40</span>)</span><br><span class="line">    </span><br><span class="line">    x_points = points[:, <span class="number">0</span>]</span><br><span class="line">    y_points = points[:, <span class="number">1</span>]</span><br><span class="line">    z_points = points[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># filter</span></span><br><span class="line">    side_filter = np.logical_and((y_points &gt; -side_range[<span class="number">1</span>]), (y_points &lt; -side_range[<span class="number">0</span>])) <span class="comment"># left y positive, right y negative</span></span><br><span class="line">    fwd_filter = np.logical_and((x_points &gt; fwd_range[<span class="number">0</span>]), (x_points &lt; fwd_range[<span class="number">1</span>]))</span><br><span class="line">    filter = np.logical_and(side_filter, fwd_filter)</span><br><span class="line">    indices = np.argwhere(filter).flatten()</span><br><span class="line"></span><br><span class="line">    x_points = x_points[indices]</span><br><span class="line">    y_points = y_points[indices]</span><br><span class="line">    z_points = z_points[indices]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(x_points.size)</span></span><br><span class="line">    <span class="comment"># print(y_points.size)</span></span><br><span class="line">    <span class="comment"># print(z_points.size)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># resolution</span></span><br><span class="line">    reso = <span class="number">0.05</span> <span class="comment"># 5cm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># transfer to image axis</span></span><br><span class="line">    x_img = (-y_points / reso).astype(np.int32)</span><br><span class="line">    y_img = (-x_points / reso).astype(np.int32)</span><br><span class="line">    x_img -= int(np.floor(side_range[<span class="number">0</span>]) / reso)</span><br><span class="line">    y_img += int(np.ceil(fwd_range[<span class="number">1</span>]) / reso)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set height range</span></span><br><span class="line">    height_range = (<span class="number">-2</span>, <span class="number">0.5</span>)</span><br><span class="line">    pixel_val = np.clip(a = z_points, a_min = height_range[<span class="number">0</span>], a_max = height_range[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># scale to 0-255</span></span><br><span class="line">    pixel_val = ((pixel_val - height_range[<span class="number">0</span>]) / float(height_range[<span class="number">1</span>] - height_range[<span class="number">0</span>]) * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initial empty image</span></span><br><span class="line">    x_max = int((side_range[<span class="number">1</span>] - side_range[<span class="number">0</span>]) / reso) + <span class="number">1</span> <span class="comment"># cols</span></span><br><span class="line">    y_max = int((fwd_range[<span class="number">1</span>] - fwd_range[<span class="number">0</span>]) / reso) + <span class="number">1</span> <span class="comment"># rows</span></span><br><span class="line">    img = np.zeros([y_max, x_max], dtype = np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fill image with height info</span></span><br><span class="line">    img[y_img, x_img] = pixel_val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># show image</span></span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>激光雷达</category>
      </categories>
      <tags>
        <tag>LiDAR</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读(2)--PointNet++</title>
    <url>/2020/01/27/pointnet2/</url>
    <content><![CDATA[<p>论文链接：<a href="https://papers.nips.cc/paper/7095-pointnet-deep-hierarchical-feature-learning-on-point-sets-in-a-metric-space.pdf" target="_blank" rel="noopener">PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space</a></p>
<p>代码：<a href="https://github.com/charlesq34/pointnet2" target="_blank" rel="noopener">tensorflow</a> <a href="https://github.com/erikwijmans/Pointnet2_PyTorch" target="_blank" rel="noopener">pytorch</a></p>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>之前很少有工作研究直接在点集上进行的深度学习，PointNet是这个方向的先驱。但是，PointNet的设计并不能捕获度量空间点的局部结构，限制了它在识别更细密度模式以及概括复杂场景方面的能力。</p>
<p>在本文中，提出了一种分层的神经网络，该网络在输入点集的嵌套分区中递归地使用PointNet(提取特征)。通过使用度量空间距离，该网络可以随着上下文比例的增加来学习局部特征。通过进一步的观察，点集通常会以不同的密度进行采样，这导致以均匀的密度进行训练的网络性能会大大降低，本文提出了新颖的集合学习层，来自适应的组合来自多个尺度的特征。</p>
<p>实验表明，本文提出的PointNet++网络能够高效、鲁棒地学习深度点集特征。特别地，在具有挑战性的3D点云基准测试中，取得了远超过state-of-the-art的结果。</p>
<h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="/2020/01/27/pointnet2/image-20200128161309179.png" alt="image-20200128161309179"></p>
<p>整体结构如图所示。</p>
<p>PointNet使用单个的最大池化操作来获得整个点集的信息，本文提出的结构构建了点的层次分组，逐层抽象出越来越大的局部区域，该结构包含一系列的点集抽象层，在每一层，通过处理将点集提取为由更少元素组成的新的集合。该点集抽象层主要由三个关键部分组成：采样层、分组层和PointNet层。</p>
<ul>
<li><p>采样层</p>
<p>采样层从输入的点集中选择一部分点构成子集，作为每个局部区域的中心点，本文中选择点的方法用的是迭代最远点采样(FPS)，即每次从剩下的点中选择距离已选点集最远的点作为新加入的点。</p>
</li>
<li><p>组合层</p>
<p>组合层选择每个中心点近邻的点构建局部区域。近邻点的选择一般有两种方法，第一种是K最近邻(kNN)查找，即选取每个点附近距离最近的K个点，K是一个固定的值；第二种是将点附近一定半径球形区域内的点作为近邻点，即ball query。和kNN相比，ball query的局部近邻保证了固定大小的区域尺度，使得空间的局部区域特征可泛化性更强。</p>
</li>
<li><p>PointNet层</p>
<p>使用一个规模较小的PointNet网络将每个局部区域的特征编码成特征向量。</p>
</li>
</ul>
<p>由于点集在不同区域的分布一般是不均匀的，这种特征是点集特征学习的一个挑战。从密集数据学习的特征可能不能概括稀疏的采样区域，同样，用稀疏点云训练的模型也可能识别不了精细的局部结构。</p>
<p>为此，本文提出了密度自适应的PointNet层来学习不同尺度区域的联合特征，并将这种使用密度自适应PointNet的层次网络命名为PointNet++。</p>
<p>在PointNet++中，每个抽象层提取多个尺度的个局部模式，并根据局部点的密度将它们自动结合，本文提出了两种不同的密度自适应层。</p>
<ul>
<li><p>Multi-scale grouping(MSG).</p>
<p><img src="/2020/01/27/pointnet2/image-20200128165447076.png" alt="image-20200128165447076"></p>
<p>一种简单有效的方法就是使用不同尺度的组合层，再用PointNet提取出各个尺度上的特征，将它们串成一个多尺度的特征，如上图所示。</p>
<p>该方法计算量较大，因为它对每个采样的中心点都要在多个尺度上运行PointNet提取特征。</p>
</li>
<li><p>Multi-resolution grouping(MRG)</p>
<p><img src="/2020/01/27/pointnet2/image-20200128165957911.png" alt="image-20200128165957911"></p>
</li>
</ul>
<p>  为了减少计算量，本文又提出了MRG方法，在该方法中，对于某个抽象层的区域特征，可以用两个向量的串联来表示，第一个向量通过使用点集抽象层汇总来自较低一级的每个子区域特征得到，第二个向量直接在局部区域的原始点上使用一个PointNet得到。</p>
<p>  当局部区域的密度比较小时，第二个向量比第一个更值得信赖，因此第二个向量所占的权重应该高一点；反过来，当局部区域密度较高时，第一个向量提供了更详细的信息。</p>
<h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h1><p>数据集：</p>
<ul>
<li>MNIST：手写数字图像，60k用于训练，10k用于测试；</li>
<li>ModelNet40：40个类别的CAD模型，9843训练，2468测试；</li>
<li>SHREC15：50个类别的1200个形状，每个类别包含24个形状，采用了5折交叉验证。</li>
<li>ScanNet：1513个室内扫描场景，1201训练，312测试。</li>
</ul>
<h2 id="3-1-欧式度量空间点集分类"><a href="#3-1-欧式度量空间点集分类" class="headerlink" title="3.1 欧式度量空间点集分类"></a>3.1 欧式度量空间点集分类</h2><p>二维使用MINIST数据集，三维使用ModelNet40数据集。</p>
<p><img src="/2020/01/27/pointnet2/image-20200128172123486.png" alt="image-20200128172123486"></p>
<p><img src="/2020/01/27/pointnet2/image-20200128172136852.png" alt="image-20200128172136852"></p>
<p>对于不同采样密度的鲁棒性实验</p>
<p><img src="/2020/01/27/pointnet2/image-20200128172236570.png" alt="image-20200128172236570"></p>
<h2 id="3-2-语义场景的点集分割"><a href="#3-2-语义场景的点集分割" class="headerlink" title="3.2 语义场景的点集分割"></a>3.2 语义场景的点集分割</h2><p>数据集：ScanNet</p>
<p><img src="/2020/01/27/pointnet2/image-20200128172430099.png" alt="image-20200128172430099"></p>
<p><img src="/2020/01/27/pointnet2/image-20200128172501557.png" alt="image-20200128172501557"></p>
<h2 id="3-3-非欧式度量空间的点集分类"><a href="#3-3-非欧式度量空间的点集分类" class="headerlink" title="3.3 非欧式度量空间的点集分类"></a>3.3 非欧式度量空间的点集分类</h2><p>数据集：SHREC15</p>
<p><img src="/2020/01/27/pointnet2/image-20200128172625876.png" alt="image-20200128172625876"></p>
<p><img src="/2020/01/27/pointnet2/image-20200128172638932.png" alt="image-20200128172638932"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>本文在PointNet的基础上提出了分层的网络结构PointNet++，在各个数据集上都取得了较好效果。主要贡献提出对输入点集的嵌套分区，以及对非均匀采样点问题的处理。</p>
<p>未来，值得思考的是如何在局部区域共享更多计算来提高推理速度，尤其是在MSG和MRG层上。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>cls.</tag>
        <tag>seg.</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读(1)--PointNet</title>
    <url>/2020/01/27/pointNet/</url>
    <content><![CDATA[<p>论文链接：<a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Qi_PointNet_Deep_Learning_CVPR_2017_paper.pdf" target="_blank" rel="noopener">PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</a></p>
<p>代码：<a href="https://github.com/charlesq34/pointnet" target="_blank" rel="noopener">tensroflow</a> <a href="https://github.com/fxia22/pointnet.pytorch" target="_blank" rel="noopener">pytorch</a> </p>
<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h1><p>点云是几何数据结构的一种重要类型，由于它的格式不规则，大多数研究人员将这种数据转换成规则的三维体素栅格或者多幅图像的集合来进行处理。但是，这种方式会增加不必要的数据量并且导致一些问题。</p>
<p>在本文中，设计了一种可以直接处理点云的新型神经网络，该网络很好的考虑的点云输入的排列不变性，将该网络命名为PointNet。PointNet为目标检测、部分分割、场景语义解析等应用提供了一种统一的结构。尽管很简单，PointNet非常的高效和有效。从实验上，它表现出与start-of-the-art同等强大或更优的性能；从理论上，本文分析了该网络学到了什么以及为何该网络对输入的扰动和破坏具有鲁棒性。</p>
<h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="/2020/01/27/pointNet/image-20200127160355226.png" alt="image-20200127160355226"></p>
<p>整体网络结构如图所示，由三个关键模块组成：</p>
<ul>
<li>最大池化层，作为对称的函数来从所有点中生成信息。</li>
</ul>
<p><img src="/2020/01/27/pointNet/image-20200127161302928.png" alt="image-20200127161302928"></p>
<p>​     为了使模型对输入点的排列具有不变性，有三种不同的策略：1）对输入按照某种规则进行排序；2）将所有可能的排列作为一个序列进行输入，训练一个RNN; 3）使用一个具有对称性的函数</p>
<p>​     本文中使用了第三种策略，采用了一个最大池化层对所有点的每个维度进行最大池化处理，生成与输入顺序无关的全局特征。</p>
<ul>
<li>一个局部和全局信息组合的结构(用于seg)</li>
</ul>
<p><img src="/2020/01/27/pointNet/image-20200127161520979.png" alt="image-20200127161520979"></p>
<p>​        在计算出全局特征向量后，在每个点的局部特征之后加上该特征向量生成新的特征，可以使每个点既有局部信息又有全局信息。</p>
<ul>
<li>对齐网络分别用于对齐输入点云和特征(T-Net)</li>
</ul>
<p><img src="/2020/01/27/pointNet/image-20200127161636465.png" alt="image-20200127161636465"></p>
<p>​     使用一个迷你网络(T-Net)来预测一个仿射变换，然后直接将该变换应用到输入点的坐标。同理，对于提取出的特征，也可以用网络学习一个更高维度的变换矩阵，并约束该矩阵为正交矩阵。</p>
<h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h1><h2 id="3-1-3D-目标分类"><a href="#3-1-3D-目标分类" class="headerlink" title="3.1 3D 目标分类"></a>3.1 3D 目标分类</h2><p>数据集：ModelNet40 shape classification benchmark。12311个CAD模型共40类，9843用于训练，2468用于测试。</p>
<p><img src="/2020/01/27/pointNet/image-20200127163950411.png" alt="image-20200127163950411"></p>
<h2 id="3-2-3D物体部分分割"><a href="#3-2-3D物体部分分割" class="headerlink" title="3.2 3D物体部分分割"></a>3.2 3D物体部分分割</h2><p>数据集：ShapeNet part data.16个类别的16881个形状，总共有50个部分的标注，大多数类别的物体标注了2-5个部分。</p>
<p><img src="/2020/01/27/pointNet/image-20200127164351963.png" alt="image-20200127164351963"></p>
<h2 id="3-3-场景语义分割"><a href="#3-3-场景语义分割" class="headerlink" title="3.3 场景语义分割"></a>3.3 场景语义分割</h2><p>数据集：Stanford 3D semantic parsing dataset.27个房间6个区域的3D扫描点，共有13个类别的语义类别。</p>
<p><img src="/2020/01/27/pointNet/image-20200127164639253.png" alt="image-20200127164639253"></p>
<p><img src="/2020/01/27/pointNet/image-20200127164650996.png" alt="image-20200127164650996"></p>
<p><img src="/2020/01/27/pointNet/image-20200127164701888.png" alt="image-20200127164701888"></p>
<h2 id="3-4-时空复杂度"><a href="#3-4-时空复杂度" class="headerlink" title="3.4 时空复杂度"></a>3.4 时空复杂度</h2><p><img src="/2020/01/27/pointNet/image-20200127164847958.png" alt="image-20200127164847958"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>本文的工作提出了一种新颖的直接输入点云的网络结构，为多种三维任务提供了统一的方法，取得了较好的结果。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>cls.</tag>
        <tag>seg.</tag>
        <tag>det.</tag>
      </tags>
  </entry>
</search>
